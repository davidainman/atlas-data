# noun possession data
nounposs_classescsv <- read.csv(paste0(possessioncldfloc, "/classes.csv"), na.strings = c(), stringsAsFactors = FALSE)
nounposs_constructionscsv <- read.csv(paste0(possessioncldfloc, "/constructions.csv"), na.strings = c(), stringsAsFactors = FALSE)
# alignment data
align_contextscsv   <- read.csv(paste0(alignmentcldfloc, '/generic-cldf/contexts.csv'))
align_selectorscsv  <- read.csv(paste0(alignmentcldfloc, '/generic-cldf/selectors.csv'))
align_languagescsv  <- read.csv(paste0(alignmentcldfloc, '/generic-cldf/languages.csv'))
align_referencescsv <- read.csv(paste0(alignmentcldfloc, '/generic-cldf/references.csv'))
align_domscsv <- read.csv(paste0(alignmentcldfloc, '/generic-cldf/doms.csv'))
align_valuescsv <- read.csv(paste0(alignmentcldfloc, '/structure-cldf/values.csv'))
lgnames <- dplyr::select(languagescsv, c('Glottocode','Name'))
# drop all derived questions
wide_data <- convertToWide(valuescsv)
# add lg names
wide_data <- merge(languagescsv[,c("Glottocode", "Name")], wide_data, by.x="Glottocode", by.y="LanguageID")
derived_qs <- colnames(wide_data)[grepl('[[:digit:]]+[[:alpha:]]',colnames(wide_data))]
align_qs <- colnames(wide_data)[grepl('Align',colnames(wide_data))]
poss_qs <- colnames(wide_data)[grepl('NounPoss',colnames(wide_data))]
wide_no_derived <- dplyr::select(wide_data, -one_of(derived_qs, align_qs, poss_qs))
wide_no_derived <- processNounPoss(wide_no_derived, nounposs_classescsv, nounposs_constructionscsv, possessioncldfloc, lgnames, warnings, errors)
# generate Align questions
wide_no_derived <- processAlignment(wide_no_derived, align_languagescsv, align_contextscsv, align_selectorscsv, align_referencescsv, align_domscsv, align_valuescsv)
featurestable<-wide_no_derived
dplyr::filter(featurestable, (`Glot-02` == 'yes' | `Glot-03` == 'yes' | `Glot-04` == 'yes' | `Glot-05` == 'yes' | `Glot-06` == 'yes') & (`Glot-01` != 'yes'))
wide_no_derived <- processGlottalized(wide_no_derived, warnings, errors)
warnings
View(warnings)
#Glot-01a
stateCol <- ifelse(featurestable$`Glot-01` == 'yes' | featurestable$`Glot-02` == 'yes' | featurestable$`Glot-03` == 'yes', 'yes',
ifelse(featurestable$`Glot-01` == 'no' & featurestable$`Glot-02` == 'no' & featurestable$`Glot-03` == 'no', 'no',
ifelse(featurestable$`Glot-01` != 'yes' & featurestable$`Glot-02` != 'yes' & featurestable$`Glot-03` != 'yes' & (featurestable$`Glot-01` == '?' | featurestable$`Glot-02` == '?' | featurestable$`Glot-03` == '?'), '?', 'ERROR: IMPOSSIBLE STATE')))
sourceCol <- collapseSourceColumns(list(featurestable$`Glot-01.Source`, featurestable$`Glot-02.Source`, featurestable$`Glot-03.Source`))
coderCol <- sapply(paste0(featurestable$`Glot-01.Coder`, ';', featurestable$`Glot-02.Coder`, ';', featurestable$`Glot-03.Coder`), collapseCoders)
featurestable <- addDerivedState(featurestable, 'Glot-01a', stateCol, sourceCol, coderCol)
#Glot-04a
stateCol <- ifelse(featurestable$`Glot-04` == 'yes' | featurestable$`Glot-05` == 'yes' | featurestable$`Glot-06` == 'yes', 'yes',
ifelse(featurestable$`Glot-04` == 'no' & featurestable$`Glot-05` == 'no' & featurestable$`Glot-06` == 'no', 'no',
ifelse(featurestable$`Glot-04` != 'yes' & featurestable$`Glot-05` != 'yes' & featurestable$`Glot-06` != 'yes' & (featurestable$`Glot-04` == '?' | featurestable$`Glot-05` == '?' | featurestable$`Glot-06` == '?'), '?', 'ERROR: IMPOSSIBLE STATE')))
sourceCol <- collapseSourceColumns(list(featurestable$`Glot-04.Source`, featurestable$`Glot-05.Source`, featurestable$`Glot-06.Source`))
coderCol <- sapply(paste0(featurestable$`Glot-04.Coder`, ';', featurestable$`Glot-05.Coder`, ';', featurestable$`Glot-06.Coder`), collapseCoders)
featurestable <- addDerivedState(featurestable, 'Glot-04a', stateCol, sourceCol, coderCol)
#Glot-04b
stateCol <- ifelse(featurestable$`Glot-01a` == 'no', 'NA',
ifelse((featurestable$`Glot-04` == 'yes' | featurestable$`Glot-05` == 'yes' | featurestable$`Glot-06` == 'yes') & featurestable$`Glot-01a` == 'yes', 'yes',
ifelse(featurestable$`Glot-04` == 'no' & featurestable$`Glot-05` == 'no' & featurestable$`Glot-06` == 'no' & featurestable$`Glot-01a` == 'yes', 'no',
ifelse(featurestable$`Glot-04` != 'yes' & featurestable$`Glot-05` != 'yes' & featurestable$`Glot-06` != 'yes' & (featurestable$`Glot-04` == '?' | featurestable$`Glot-05` == '?' | featurestable$`Glot-06` == '?') & featurestable$`Glot-01a` == 'yes', '?', 'ERROR: IMPOSSIBLE STATE'))))
sourceCol <- collapseSourceColumns(list(featurestable$`Glot-04.Source`, featurestable$`Glot-05.Source`, featurestable$`Glot-06.Source`))
coderCol <- sapply(paste0(featurestable$`Glot-04.Coder`, ';', featurestable$`Glot-05.Coder`, ';', featurestable$`Glot-06.Coder`), collapseCoders)
featurestable <- addDerivedState(featurestable, 'Glot-04b', stateCol, sourceCol, coderCol)
#Glot-03a
stateCol <- ifelse(featurestable$`Glot-01a` == '?' | featurestable$`Glot-03` == '?', '?',
ifelse(featurestable$`Glot-01a` == 'yes' & featurestable$`Glot-03` == 'yes', 'yes',
ifelse(featurestable$`Glot-01a` == 'yes' & featurestable$`Glot-03` == 'no', 'no', 'NA')))
sourceCol <- collapseSourceColumns(list(featurestable$`Glot-01a.Source`, featurestable$`Glot-03.Source`))
coderCol <- featurestable$`Glot-03.Coder`
featurestable <- addDerivedState(featurestable, 'Glot-03a', stateCol, sourceCol, coderCol)
#Glot-04c
stateCol <- ifelse(featurestable$`Glot-04a` == '?' | featurestable$`Glot-04` == '?', '?',
ifelse(featurestable$`Glot-04a` == 'yes' & featurestable$`Glot-04` == 'yes', 'yes',
ifelse(featurestable$`Glot-04a` == 'yes' & featurestable$`Glot-04` == 'no', 'no', 'NA')))
sourceCol <- collapseSourceColumns(list(featurestable$`Glot-04a.Source`, featurestable$`Glot-04.Source`))
coderCol <- featurestable$`Glot-04.Coder`
featurestable <- addDerivedState(featurestable, 'Glot-04c', stateCol, sourceCol, coderCol)
#Glot-05a
stateCol <- ifelse(featurestable$`Glot-04a` == '?' | featurestable$`Glot-05` == '?', '?',
ifelse(featurestable$`Glot-04a` == 'yes' & featurestable$`Glot-05` == 'yes', 'yes',
ifelse(featurestable$`Glot-04a` == 'yes' & featurestable$`Glot-05` == 'no', 'no', 'NA')))
sourceCol <- collapseSourceColumns(list(featurestable$`Glot-04a.Source`, featurestable$`Glot-05.Source`))
coderCol <- featurestable$`Glot-05.Coder`
featurestable <- addDerivedState(featurestable, 'Glot-05a', stateCol, sourceCol, coderCol)
#Glot-06a
stateCol <- ifelse(featurestable$`Glot-04a` == '?' | featurestable$`Glot-06` == '?', '?',
ifelse(featurestable$`Glot-04a` == 'yes' & featurestable$`Glot-06` == 'yes', 'yes',
ifelse(featurestable$`Glot-04a` == 'yes' & featurestable$`Glot-06` == 'no', 'no', 'NA')))
sourceCol <- collapseSourceColumns(list(featurestable$`Glot-04a.Source`, featurestable$`Glot-06.Source`))
coderCol <- featurestable$`Glot-06.Coder`
featurestable <- addDerivedState(featurestable, 'Glot-06a', stateCol, sourceCol, coderCol)
#warnings
warningsInt <- warnings
warningsList <- dplyr::filter(featurestable, (`Glot-02` == 'yes' | `Glot-03` == 'yes' | `Glot-04` == 'yes' | `Glot-05` == 'yes' | `Glot-06` == 'yes') & (`Glot-01` != 'yes'))
addErrorsOrWarnings('Warning', warningsList, warningsInt, 'Glot', "Glot-01 is not 'yes' but Glot-02 - Glot-06 contains at least one 'yes'")
warningsInt
warningsList
View(warningsList)
addErrorsOrWarnings('Warning', warningsList, warningsInt, 'Glot', "Glot-01 is not 'yes' but Glot-02 - Glot-06 contains at least one 'yes'")
warningsInt
isErrorOrWarning<-"Warning"
ewList<-warningsList
ewDataFrame<-warningsInt
feature<-'Glot'
text<-"Glot-01 is not 'yes' but Glot-02 - Glot-06 contains at least one 'yes'"
(isErrorOrWarning == 'Error')
data.frame(matrix(ncol=5,nrow=0, dimnames=list(NULL, c('Feature', 'Language', 'Glottocode', 'Coder', 'WarningText'))))
ewRows = data.frame(matrix(ncol=5,nrow=0, dimnames=list(NULL, c('Feature', 'Language', 'Glottocode', 'Coder', 'WarningText'))))
ewList$LanguageID
addErrorsOrWarnings <- function(isErrorOrWarning, ewList, ewDataFrame, feature, text) {
if (isErrorOrWarning == 'Error') {
ewRows = data.frame(matrix(ncol=5,nrow=0, dimnames=list(NULL, c('Feature', 'Language', 'Glottocode', 'Coder', 'ErrorText'))))
} else if (isErrorOrWarning == 'Warning') {
ewRows = data.frame(matrix(ncol=5,nrow=0, dimnames=list(NULL, c('Feature', 'Language', 'Glottocode', 'Coder', 'WarningText'))))
} else {
stop('Invalid value passed to addErrorsOrWarnings function: Only "Warning" or "Error" accepted.')
}
for (glotto in ewList$Glottocode) {
# all features until now have the same coder, we can assume feat-01-Coder is sufficient
ewRows[nrow(ewRows) + 1, ] = c(feature, ewList$Name[ewList$Glottocode==glotto], glotto, ewList[[paste0(feature,'-01-Coder')]][ewList$LanguageID==glotto], text)
}
#write back to global variable
ewDataFrameObj <- deparse(substitute(ewDataFrame))
assign(ewDataFrameObj, value = rbindlist(list(ewDataFrame, ewRows)), envir = parent.frame())
}
wide_no_derived <- processGlottalized(wide_no_derived, warnings, errors)
ewRows[nrow(ewRows) + 1, ] = c(feature, ewList$Name[ewList$Glottocode==glotto], glotto, ewList[[paste0(feature,'-01-Coder')]][ewList$LanguageID==glotto], text)
c(feature, ewList$Name[ewList$Glottocode==glotto], glotto, ewList[[paste0(feature,'-01-Coder')]][ewList$LanguageID==glotto], text)
c(feature, ewList$Name[ewList$Glottocode==glotto], glotto, ewList[[paste0(feature,'-01-Coder')]][ewList$Glottocode==glotto], text)
feature
ewList$Name[ewList$Glottocode==glotto]
lgnames
c(feature, ewList$Name[ewList$Glottocode==glotto], glotto, ewList[[paste0(feature,'-01-Coder')]][ewList$Glottocode==glotto], text)
lgnames$Name[lgnames$Glottocode == ewList$Glottocode==glotto]
lgnames$Name[lgnames$Glottocode == glotto]
c(feature, lgnames$Name[lgnames$Glottocode == glotto], glotto, ewList[[paste0(feature,'-01-Coder')]][ewList$Glottocode==glotto], text)
feature
c(feature, lgnames$Name[lgnames$Glottocode == glotto], glotto, ewList[[paste0(feature,'-01.Coder')]][ewList$Glottocode==glotto], text)
paste0(feature,'-01.Coder')
ewList[[paste0(feature,'-01.Coder')]]
ewList
View(ewList)
ewList[[paste0(feature,'-01.Coder')]][ewList$Glottocode==glotto]
ewList$Glottocode
glotto
addErrorsOrWarnings <- function(isErrorOrWarning, ewList, ewDataFrame, feature, text, lgnames) {
if (isErrorOrWarning == 'Error') {
ewRows = data.frame(matrix(ncol=5,nrow=0, dimnames=list(NULL, c('Feature', 'Language', 'Glottocode', 'Coder', 'ErrorText'))))
} else if (isErrorOrWarning == 'Warning') {
ewRows = data.frame(matrix(ncol=5,nrow=0, dimnames=list(NULL, c('Feature', 'Language', 'Glottocode', 'Coder', 'WarningText'))))
} else {
stop('Invalid value passed to addErrorsOrWarnings function: Only "Warning" or "Error" accepted.')
}
for (glotto in ewList$Glottocode) {
# all features until now have the same coder, we can assume feat-01-Coder is sufficient
ewRows[nrow(ewRows) + 1, ] = c(feature, lgnames$Name[lgnames$Glottocode == glotto], glotto, ewList[[paste0(feature,'-01.Coder')]][ewList$Glottocode==glotto], text)
}
#write back to global variable
ewDataFrameObj <- deparse(substitute(ewDataFrame))
assign(ewDataFrameObj, value = rbindlist(list(ewDataFrame, ewRows)), envir = parent.frame())
}
source('utils.R')
source('nounposs.R')
source('lat.R')
source('veluv.R')
source('glot.R')
source('cor.R')
source('toneprom.R')
source('syll.R')
source('ppron.R')
source('sgpl.R')
source('monpl.R')
source('wo.R')
source('attr.R')
source('gend.R')
source('soccaus.R')
source('dem.R')
source('appr.R')
source('nounposs.R')
source('align.R')
warnings <- data.table(matrix(ncol=5,nrow=0, dimnames=list(NULL, c('Feature', 'Language', 'Glottocode', 'Coder', 'WarningText'))))
errors   <- data.table(matrix(ncol=5,nrow=0, dimnames=list(NULL, c('Feature', 'Language', 'Glottocode', 'Coder', 'ErrorText'))))
# read csv files
# main database
valuescsv <- read.csv(paste0(maincldfloc, "/values.csv"), na.strings = c(), colClasses = c("character"), stringsAsFactors = FALSE)
languagescsv <- read.csv(paste0(maincldfloc, "/languages.csv"), na.strings = c(), stringsAsFactors = FALSE)
parameterscsv <- read.csv(paste0(maincldfloc, "/parameters.csv"), na.strings = c(), stringsAsFactors = FALSE)
codescsv <- read.csv(paste0(maincldfloc, "/codes.csv"), na.strings = c(), stringsAsFactors = FALSE)
# sg-pl verbs
sgplverbs <- read.csv(paste0(sgplloc, "/verbs.csv"), check.names = FALSE, stringsAsFactors = FALSE)
# noun possession data
nounposs_classescsv <- read.csv(paste0(possessioncldfloc, "/classes.csv"), na.strings = c(), stringsAsFactors = FALSE)
nounposs_constructionscsv <- read.csv(paste0(possessioncldfloc, "/constructions.csv"), na.strings = c(), stringsAsFactors = FALSE)
# alignment data
align_contextscsv   <- read.csv(paste0(alignmentcldfloc, '/generic-cldf/contexts.csv'))
align_selectorscsv  <- read.csv(paste0(alignmentcldfloc, '/generic-cldf/selectors.csv'))
align_languagescsv  <- read.csv(paste0(alignmentcldfloc, '/generic-cldf/languages.csv'))
align_referencescsv <- read.csv(paste0(alignmentcldfloc, '/generic-cldf/references.csv'))
align_domscsv <- read.csv(paste0(alignmentcldfloc, '/generic-cldf/doms.csv'))
align_valuescsv <- read.csv(paste0(alignmentcldfloc, '/structure-cldf/values.csv'))
View(errors)
View(warnings)
lgnames <- dplyr::select(languagescsv, c('Glottocode','Name'))
# drop all derived questions
wide_data <- convertToWide(valuescsv)
# add lg names
wide_data <- merge(languagescsv[,c("Glottocode", "Name")], wide_data, by.x="Glottocode", by.y="LanguageID")
# remove derived questions (+ align, nounposs)
derived_qs <- colnames(wide_data)[grepl('[[:digit:]]+[[:alpha:]]',colnames(wide_data))]
align_qs <- colnames(wide_data)[grepl('Align',colnames(wide_data))]
poss_qs <- colnames(wide_data)[grepl('NounPoss',colnames(wide_data))]
wide_no_derived <- dplyr::select(wide_data, -one_of(derived_qs, align_qs, poss_qs))
# generate NounPoss questions
wide_no_derived <- processNounPoss(wide_no_derived, nounposs_classescsv, nounposs_constructionscsv, possessioncldfloc, lgnames, warnings, errors)
# generate Align questions
wide_no_derived <- processAlignment(wide_no_derived, align_languagescsv, align_contextscsv, align_selectorscsv, align_referencescsv, align_domscsv, align_valuescsv)
# generate other derived questions
wide_no_derived <- processLaterals(wide_no_derived, lgnames, warnings, errors)
wide_no_derived <- processVeluv(wide_no_derived, lgnames, warnings, errors)
wide_no_derived <- processGlottalized(wide_no_derived, lgnames, warnings, errors)
wide_no_derived <- processCoronals(wide_no_derived, lgnames, warnings, errors)
wide_no_derived <- processToneProm(wide_no_derived, lgnames, warnings, errors)
wide_no_derived <- processSyllable(wide_no_derived, lgnames, warnings, errors)
wide_no_derived <- processPronouns(wide_no_derived, lgnames, warnings, errors)
wide_no_derived <- processSgPl(wide_no_derived, sgplverbs, lgnames, warnings, errors)
wide_no_derived <- processMonPl(wide_no_derived, lgnames, warnings, errors)
wide_no_derived <- processWordOrder(wide_no_derived, lgnames, warnings, errors)
wide_no_derived <- processGenderlects(wide_no_derived, lgnames, warnings, errors)
wide_no_derived <- processSocCaus(wide_no_derived, lgnames, warnings, errors)
wide_no_derived <- processDemonstratives(wide_no_derived, lgnames, warnings, errors)
wide_no_derived <- processAttributives(wide_no_derived, lgnames, warnings, errors)
wide_no_derived <- processApprehensional(wide_no_derived, lgnames, warnings, errors)
# make everything a character
wide_no_derived <- wide_no_derived %>% mutate(across(everything(), as.character))
View(errors)
View(warnings)
nrow(filter(warnings, Feature == "NounPoss"))
classes <- as.data.frame(googlesheets4::read_sheet(ss=url, sheet='Noun Classes', na='', col_types='c'))
#!/usr/bin/env Rscript
suppressPackageStartupMessages(library(argparse))
suppressPackageStartupMessages(library(dplyr))
suppressPackageStartupMessages(library(data.table))
suppressPackageStartupMessages(library(tidyr))
suppressPackageStartupMessages(library(tibble))
suppressPackageStartupMessages(library(stringr))
suppressPackageStartupMessages(library(rje))
suppressPackageStartupMessages(library(googledrive))
suppressPackageStartupMessages(library(googlesheets4))
suppressPackageStartupMessages(library(leaflet))
suppressPackageStartupMessages(library(htmlwidgets))
#suppressPackageStartupMessages(library(gsheet))
#library(tidyverse)
options(warn=-1)
source('make-maps.R')
errorRows = data.frame(matrix(ncol=5,nrow=0, dimnames=list(NULL, c('Feature', 'Language', 'Glottocode', 'Coder', 'ErrorText'))))
warningRows = data.frame(matrix(ncol=5,nrow=0, dimnames=list(NULL, c('Feature', 'Language', 'Glottocode', 'Coder', 'WarningText'))))
allurls$url[allurls$feature == 'Noun Possession Classes']
allurls <- dplyr::filter(allurls, feature %in% onlyFeatures, .preserve = TRUE)
allurls <- readimportdata(importdata)
importdata
importdata<-"~/Documents/GitHub/ooa-processing/import/importdata.csv"
allurls <- readimportdata(importdata)
readimportdata <- function(importdata) {
allurls <- read.csv(importdata, stringsAsFactors=FALSE)
#only for gsheet
#allurls$csvURL <- suppressWarnings(construct_download_url(allurls$url, format='csv', sheetid=NULL))
return(allurls)
}
allurls <- readimportdata(importdata)
url<-allurls$url[allurls$feature == 'Noun Possession Classes']
errorRows = data.frame(matrix(ncol=5,nrow=0, dimnames=list(NULL, c('Feature', 'Language', 'Glottocode', 'Coder', 'ErrorText'))))
warningRows = data.frame(matrix(ncol=5,nrow=0, dimnames=list(NULL, c('Feature', 'Language', 'Glottocode', 'Coder', 'WarningText'))))
classes <- as.data.frame(googlesheets4::read_sheet(ss=url, sheet='Noun Classes', na='', col_types='c'))
googlesheets4::gs4_deauth()
options(gargle_oauth_cache = ".secrets")
gargle::gargle_oauth_cache()
googlesheets4::gs4_auth(path='~/Documents/GitHub/ooa-processing/import/out-of-asia-key.json')
httr::set_config(httr::config(http_version = 2))
errorRows = data.frame(matrix(ncol=5,nrow=0, dimnames=list(NULL, c('Feature', 'Language', 'Glottocode', 'Coder', 'ErrorText'))))
warningRows = data.frame(matrix(ncol=5,nrow=0, dimnames=list(NULL, c('Feature', 'Language', 'Glottocode', 'Coder', 'WarningText'))))
classes <- as.data.frame(googlesheets4::read_sheet(ss=url, sheet='Noun Classes', na='', col_types='c'))
constructions <- as.data.frame(googlesheets4::read_sheet(ss=url, sheet='Constructions', na='', col_types='c'))
#delete first non-header row: instructions to coders
classes <- classes[-1,]
constructions <- constructions[-1,]
glotto="amar1274"
classInClasses <- dplyr::filter(classes, as.character(glottocode) == glotto, as.character(coder) != '') %>% select(Noun.Class)
classInCxns <- dplyr::filter(constructions, as.character(glottocode) == glotto) %>% select(Noun.class)
names(classInCxns)[names(classInCxns) == "Noun.class"] <- "Noun.Class"
name <- unique(dplyr::filter(constructions, as.character(glottocode) == glotto)$name)
coder <- paste(unique(trimws(unlist(strsplit(dplyr::filter(constructions, as.character(glottocode) == glotto)$coder, ';')))), collapse=';')
cxnClasses = c()
for (cxnClass in classInCxns$Noun.Class) {
cxnClasses = c(cxnClasses, strsplit(cxnClass, "( )*;( )*"))
}
cxnClasses
cxnClasses = unique(unlist(cxnClasses))
cxnClasses
class="inalienable"
(!class %in% cxnClasses)
(!class %in% classInCxns$Noun.Class && class != 'alienable')
semantics <- unlist(strsplit(classes$Semantic.Categories[classes$glottocode == glotto & classes$Noun.Class == class], "( )*;( )*"))
classInCxns$Noun.Class
classInCxns
classInClasses <- dplyr::filter(classes, as.character(glottocode) == glotto, as.character(coder) != '') %>% select(Noun.Class)
classInCxns <- dplyr::filter(constructions, as.character(glottocode) == glotto) %>% select(Noun.class)
names(classInCxns)[names(classInCxns) == "Noun.class"] <- "Noun.Class"
name <- unique(dplyr::filter(constructions, as.character(glottocode) == glotto)$name)
coder <- paste(unique(trimws(unlist(strsplit(dplyr::filter(constructions, as.character(glottocode) == glotto)$coder, ';')))), collapse=';')
cxnClasses = c()
classInCxns
(!class %in% classInCxns$Noun.Class && class != 'alienable')
class
classInCxns$Noun.Class
classInCxns$Class_ID
classescsv
constructionscsv$Class_ID[constructionscsv$Glottocode=="amar1274"]
paste0(glotto,'_alienable')
defaultclass <- classes$Noun.Class[classes$glottocode == glotto & grepl('default', classes$Semantic.Categories)]
glottoconstructions <- dplyr::filter(constructions, glottocode == glotto)
defaultshapes <- unique(glottoconstructions$Construction.example.shape[glottoconstructions$Construction.Type != 'UNPOSSESSION' & grepl(paste0('(^|\\s|;)',defaultclass,'($|\\s|;)'), glottoconstructions$Noun.class)])
glotto="wara1302"
defaultclass <- classes$Noun.Class[classes$glottocode == glotto & grepl('default', classes$Semantic.Categories)]
glottoconstructions <- dplyr::filter(constructions, glottocode == glotto)
defaultshapes <- unique(glottoconstructions$Construction.example.shape[glottoconstructions$Construction.Type != 'UNPOSSESSION' & grepl(paste0('(^|\\s|;)',defaultclass,'($|\\s|;)'), glottoconstructions$Noun.class)])
!(is.na(featurestable$WO.03[featurestable$glottocode == glotto]))
is.na(featurestable$WO.03[featurestable$glottocode == glotto]))
is.na(featurestable$WO.03[featurestable$glottocode == glotto])
featurestable$WO.03
featurestable
googlesheets4::gs4_deauth()
options(gargle_oauth_cache = ".secrets")
gargle::gargle_oauth_cache()
#If you are using your own account, uncomment the following line and comment out the json
#If you are using the json key, make sure to email David (havennah@gmail.com) and ask for the file
#googlesheets4::gs4_auth(token = ".secrets", email="havennah@gmail.com")
googlesheets4::gs4_auth(path='out-of-asia-key.json')
warnings <- data.table(matrix(ncol=5,nrow=0, dimnames=list(NULL, c('Feature', 'Language', 'Glottocode', 'Coder', 'WarningText'))))
errors   <- data.table(matrix(ncol=5,nrow=0, dimnames=list(NULL, c('Feature', 'Language', 'Glottocode', 'Coder', 'ErrorText'))))
allurls <- readimportdata(importdata)
fs = stitchSpreadsheets(allurls)
stitchSpreadsheets <- function(allurls) {
features <- data.frame()
for (feature in allurls$feature) {
#skip non-features and special features
#if (feature == 'Alignment') {
#  allurls$shortname[allurls$feature == feature] <- 'Align'
#  next
#}
#if (feature == 'Nominal Class Systems') {
#  allurls$shortname[allurls$feature == feature] <- 'NomClass'
#  next
#}
if (feature == 'Sources' | feature == 'Errors' | feature == 'Metadata' | feature == 'Alignment Errors' | feature == 'Noun Possession Classes' | feature == 'Nominal Class Systems' | feature == 'Alignment' | feature == 'Alignment Folder' | feature == 'Alignment Output' | feature == 'Sg-Pl Verbs' ) {
next
}
featuretable <- as.data.frame(googlesheets4::read_sheet(ss=allurls$url[allurls$feature == feature], na='', col_types='c'))
# copy value from row1 into 'glottocode' ("question") -- we discard 'name'
featuretable[1, "glottocode"] <- featuretable[1, "name"]
columns <- colnames(featuretable)
shortname <- sub('\\..*', '', columns[grepl("\\.01", columns)][1])
allurls$shortname[allurls$feature == feature] <- shortname
columns_features <- columns[grepl(paste0(shortname, '\\.[0-9]+'), columns)]
columns_sources <- columns[grepl('source', columns)]
#lowercase column names except for shortname
names(featuretable) <- sub(paste0(paste0('\\b(', shortname), ')(\\..*)'), '\\1\\L\\2', names(featuretable), perl=TRUE)
#lowercase all feature values
for (col in columns_features) {
#remove parentheses and lowercase all feature values
featuretable[featuretable$name != 'question', which(colnames(featuretable)==col)] <- gsub("\\s*\\([^\\)]+\\)","",tolower(featuretable[featuretable$name != 'question', which(colnames(featuretable)==col)]))
#Manipulate question text: remove parentheses, lowercase feature values except for NA
questiontext <- trimws(gsub("(.*)\\s*(\\{.*\\})", "\\1", featuretable[featuretable$name == 'question', which(colnames(featuretable)==col)], perl=TRUE))
questionstates <- unlist(strsplit(sub('.*\n?.*\\{(.*)\\}.*', '\\L\\1', featuretable[featuretable$name == 'question', which(colnames(featuretable)==col)], perl=TRUE), '\\|'))
#check for multistates
#WARNING: This only supports ONE multistate set per question!
is_multistates <- FALSE
multistates <- NA
for (qstate in questionstates) {
if (grepl('\\[', qstate)) {
is_multistates <- TRUE
multistates <- unlist(strsplit(sub('.*\n?.*\\[(.*)\\].*', '\\L\\1', qstate, perl=TRUE), ','))
multistates <- trimws(gsub("(.*)(\\([^\\)]+\\))", "\\1", multistates))
questionstates <- questionstates[!questionstates %in% c(qstate)]
}
}
questionstates <- trimws(gsub("(.*)(\\([^\\)]+\\))", "\\1", questionstates))
questionstates[questionstates=='na'] <- 'NA'
if (!is_multistates) {
featuretable[featuretable$name == 'question', which(colnames(featuretable)==col)] <- paste(questiontext, '{', paste0(questionstates, collapse=' | '), '}')
} else {
featuretable[featuretable$name == 'question', which(colnames(featuretable)==col)] <- paste(questiontext, '{', paste0(questionstates, collapse=' | '), '| [', paste0(multistates, collapse=' , '), '] }')
}
}
#uppercase 'NA'
featuretable[featuretable=='na' | featuretable=='nA' | featuretable=='Na'] <- 'NA'
#lowercase sources
for (col in columns_sources) {
featuretable[, which(colnames(featuretable)==col)] <- tolower(featuretable[, which(colnames(featuretable)==col)])
}
#add the shortname to Source, Remark, coder if not there
grepstr <- paste(paste0('^(?!', shortname), ').*((r|R)emark|(c|C)itation|(s|S)ource)\\..*|coder', sep='')
for (col in columns[grepl(grepstr, columns, perl=TRUE)]) {
names(featuretable)[names(featuretable) == col] <- paste0(shortname, paste0('.', col))
}
if (nrow(features) == 0) {
features <- featuretable
} else {
featuretable <- dplyr::select(featuretable, -one_of('iso', 'name', 'family', 'macroareas'))
features <- merge(features, featuretable, by.x='glottocode', by.y='glottocode', all=TRUE)
}
}
#generate sample list
samples <- as.data.frame(googlesheets4::read_sheet(allurls$url[allurls$feature == 'Sources'], na='', col_types='c')) %>% select(contains('glottocode') | contains('sample'))
#trim whitespace
features <- as.data.frame(apply(features, 2, function(x)trimws(x)), stringsAsFactors = FALSE)
shortnames <- dplyr::select(allurls, feature, shortname) %>% dplyr::filter(feature != 'Sources' & feature != 'Errors' & feature != 'Alignment Errors' & feature != 'Noun Possession Classes' & feature != 'Metadata' & feature != 'Alignment Folder')
return(list(features, shortnames, samples))
}
fs = stitchSpreadsheets(allurls)
features <- fs[[1]]
shortnames <- fs[[2]]
samples <- fs[[3]]
url
errorRows = data.frame(matrix(ncol=5,nrow=0, dimnames=list(NULL, c('Feature', 'Language', 'Glottocode', 'Coder', 'ErrorText'))))
warningRows = data.frame(matrix(ncol=5,nrow=0, dimnames=list(NULL, c('Feature', 'Language', 'Glottocode', 'Coder', 'WarningText'))))
classes <- as.data.frame(googlesheets4::read_sheet(ss=url, sheet='Noun Classes', na='', col_types='c'))
constructions <- as.data.frame(googlesheets4::read_sheet(ss=url, sheet='Constructions', na='', col_types='c'))
classes <- classes[-1,]
constructions <- constructions[-1,]
glottocodes <- unique(classes$glottocode)
glotto="wara1302"
classInClasses <- dplyr::filter(classes, as.character(glottocode) == glotto, as.character(coder) != '') %>% select(Noun.Class)
classInCxns <- dplyr::filter(constructions, as.character(glottocode) == glotto) %>% select(Noun.class)
names(classInCxns)[names(classInCxns) == "Noun.class"] <- "Noun.Class"
name <- unique(dplyr::filter(constructions, as.character(glottocode) == glotto)$name)
coder <- paste(unique(trimws(unlist(strsplit(dplyr::filter(constructions, as.character(glottocode) == glotto)$coder, ';')))), collapse=';')
cxnClasses = c()
for (cxnClass in classInCxns$Noun.Class) {
cxnClasses = c(cxnClasses, strsplit(cxnClass, "( )*;( )*"))
}
cxnClasses = unique(unlist(cxnClasses))
for (class in classInClasses$Noun.Class) {
if (!class %in% cxnClasses) {
errorRows[nrow(errorRows)+1,] = c('NounPoss', name, glotto, coder, paste0("No construction found for class ", class, "."))
} else if (!class %in% classInCxns$Noun.Class && class != 'alienable') {
warningRows[nrow(warningRows)+1,] = c('NounPoss', name, glotto, coder, paste0("Unique construction for ", class, " not found in constructions."))
}
semantics <- unlist(strsplit(classes$Semantic.Categories[classes$glottocode == glotto & classes$Noun.Class == class], "( )*;( )*"))
for (s in semantics) {
if (!s %in% CONCEPTUALLY_INALIENABLE && !s %in% CONCEPTUALLY_NONPOSSESSIBLE && s != "default" && s != "mixed") {
errorRows[nrow(errorRows)+1,] = c('NounPoss', name, glotto, coder, paste0("Unknown semantic type detected for class ", class, ": ", s, "."))
}
}
}
Indirects <- dplyr::filter(constructions, as.character(glottocode) == glotto, as.character(coder) != '', as.character(Construction.Type) == 'CLASS' | as.character(Construction.Type) == 'CLAUSE' | as.character(Construction.Type) == 'PRO_CLASS' | as.character(Construction.Type) == 'PRO_CLAUSE')
NonNullNonPossessions <- dplyr::filter(constructions, as.character(glottocode) == glotto, as.character(coder) != '', as.character(Construction.Type) == 'UNPOSSESSION', as.character(Construction.example.shape) != 'NULL', as.character(Construction.example.shape) != 'N')
for (class in cxnClasses) {
hasIndirect <- FALSE
hasNonNullNonPossession <- FALSE
for (IndCxnClass in Indirects$Noun.class) {
if (class %in% unlist(strsplit(IndCxnClass, "( )*;( )*"))) {
hasIndirect <- TRUE
}
}
for (NonPossClass in NonNullNonPossessions$Noun.class) {
if (class %in% unlist(strsplit(NonPossClass, "( )*;( )*"))) {
hasNonNullNonPossession <- TRUE
}
}
if (hasIndirect & hasNonNullNonPossession) {
warningRows[nrow(warningRows)+1,] = c('NounPoss', name, glotto, coder, paste("The class",class,"has both an INDIRECT possession construction and a UNPOSSESSION construction."))
}
}
cxns <- dplyr::filter(constructions, as.character(glottocode) == glotto, as.character(coder) != '', as.character(Construction.Type) != 'UNPOSSESSION', as.character(Construction.Type) != 'POSSESSION', as.character(Noun.class) != 'SUPPLETIVE')
if (nrow(cxns) > 0) {
for (i in 1:nrow(cxns)) {
hasPSSR = grepl('PSSR', cxns[i,"Construction.example.shape"])
hasPSSD = grepl('PSSD', cxns[i,"Construction.example.shape"])
isPronominal = grepl('PRO', cxns[i,"Construction.Type"])
if (!hasPSSR && !hasPSSD) {
errorRows[nrow(errorRows)+1,] = c('NounPoss', name, glotto, coder, paste("Strings 'PSSR' and 'PSSD' not found in possession construction for",name,cxns[i,"Noun.class"]))
} else if (!hasPSSR && !isPronominal) {
errorRows[nrow(errorRows)+1,] = c('NounPoss', name, glotto, coder, paste("String 'PSSR' not found in possession construction for",name,cxns[i,"Noun.class"]))
} else if (!hasPSSD) {
errorRows[nrow(errorRows)+1,] = c('NounPoss', name, glotto, coder, paste("String 'PSSD' not found in possession construction for",name,cxns[i,"Noun.class"]))
}
}
}
uncxns <- dplyr::filter(constructions, as.character(glottocode) == glotto, as.character(coder) != '', as.character(Construction.Type) == 'UNPOSSESSION')
if (nrow(uncxns > 0)) {
for (i in 1:nrow(uncxns)) {
hasPSSR = grepl('PSSR', uncxns[i,"Construction.example.shape"])
hasPSSD = grepl('PSSD', uncxns[i,"Construction.example.shape"])
if (hasPSSR || hasPSSD) {
errorRows[nrow(errorRows)+1,] = c('NounPoss', name, glotto, coder, paste("Strings 'PSSR' and 'PSSD' cannot be present in unpossession construction:",name,cxns[i,"Noun.class"]))
}
}
}
defaultclass <- classes$Noun.Class[classes$glottocode == glotto & grepl('default', classes$Semantic.Categories)]
defaultclass
glottoconstructions <- dplyr::filter(constructions, glottocode == glotto)
glottoconstructions
defaultshapes <- unique(glottoconstructions$Construction.example.shape[glottoconstructions$Construction.Type != 'UNPOSSESSION' & grepl(paste0('(^|\\s|;)',defaultclass,'($|\\s|;)'), glottoconstructions$Noun.class)])
defaultshapes
(!(is.na(featurestable$WO.03[featurestable$glottocode == glotto])))
featurestable$WO.03
featurestable
featurestable<-features
(!(is.na(featurestable$WO.03[featurestable$glottocode == glotto])))
wo_order <- featurestable$WO.03[featurestable$glottocode == glotto]
wo_order
np_orders <- c()
for (shape in defaultshapes) {
if (grepl("PSSR", shape) & grepl("PSSD", shape)) {
PSSR_loc <- unlist(gregexpr("PSSR", shape))[1]
PSSD_loc <- unlist(gregexpr("PSSD", shape))[1]
if (PSSR_loc < PSSD_loc) {
np_orders <- c(np_orders, "PSSR-PSSD")
} else {
np_orders <- c(np_orders, "PSSD-PSSR")
}
}
}
np_orders
View(features)
unique(features$WO.03)
